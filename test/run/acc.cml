/**
tail-recursive accumulate function
This test checks that tail-call optimization is working correctly.
*/

module fib

import { now } from time

func arithmetic_sum(n: int64, a: int64, d: int64, acc: int64): int64 {
    return if n == 0 then acc
    else arithmetic_sum(n - 1, a + d, d, acc + a)
}

export func main(): int sync {
    let n = 100000  // number of terms
    let a = 1       // first term
    let d = 3       // common difference
    println("Start computing arithmetic_sum(n={}, a={}, d={})...".format(n, a, d))
    let start = now()
    let res = arithmetic_sum(n, a, d, 0)
    let duration = now() - start
    println("Sum of arithmetic series = {} (computed in {} seconds)".format(res, duration))
    return 0
}