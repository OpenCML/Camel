/**
tail-recursive accumulate function
This test checks that tail-call optimization is working correctly.
*/

module arithmetic_sum

import { now } from time

func sum(n: int, a: int, d: int, acc: int): int {
    return if n == 0 then acc else sum(n - 1, a + d, d, acc + a)
}

func main(): int sync {
    let n = 100000  // number of terms
    let a = 1       // first term
    let d = 3       // common difference
    println("Start computing arithmetic_sum(n={}, a={}, d={})...".format(n, a, d))
    let start = now()
    let res = sum(n, a, d, 0)
    let duration = now() - start
    println("Sum of arithmetic series = {} (computed in {} seconds)".format(res, duration))
    return 0
}