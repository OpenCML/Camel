module snake

import { now } from time
import { set_terminal_raw_mode, has_input, get_char } from os

// Map size
let WIDTH = 20
let HEIGHT = 10

// Coordinate point
type Point = {
    x: int,
    y: int
}

func render(snake: Point[]): void sync {
    print("\033[2J\033[H")  // Clear screen
    let rows = range(0, HEIGHT)

    rows.foreach((y: int) => sync {
        let cols = range(0, WIDTH)
        let lines = cols.map((x: int): string => sync {
            let p = { x: x, y: y }
            return if snake.contains(p) then "O" else "."
        })
        println("".join(lines))
    })

    println("")
}

func move_snake(snake: Point[], dir: string): Point[] {
    let head = snake.head()
    let new_head = match dir {
        case 'w' => { x: head.$x, y: head.$y - 1 }  // Up
        case 'a' => { x: head.$x - 1, y: head.$y }  // Left
        case 's' => { x: head.$x, y: head.$y + 1 }  // Down
        case 'd' => { x: head.$x + 1, y: head.$y }  // Right
        case _ => head
    }
    return [new_head].extend(snake.slice(0, snake.len() - 1))
}

// Check if the snake hits the wall
func hit_wall(p: Point): bool {
    return p.$x < 0 || p.$x >= WIDTH || p.$y < 0 || p.$y >= HEIGHT
}

// Recursive game loop
func game_loop(snake: Point[], dir: string, steps: int) sync {
    render(snake)
    let new_snake = move_snake(snake, dir)
    let head = new_snake.head()

    if hit_wall(head) then {
        println("Game over! You hit the wall after {} steps.".format(steps))
    } else sync {
        sleep(500)  // Delay for visual effect
        // Recursive call for next frame
        let d = if has_input() then (input()).head() else dir
        game_loop(new_snake, d, steps + 1)
    }
}

// Entry point
func main(): int sync {
    set_terminal_raw_mode(true)
    let initial_snake = [{ x: 5, y: 5}, { x: 4, y: 5}, { x: 3, y: 5}]
    game_loop(initial_snake, 'w', 0)
    return 0
}
