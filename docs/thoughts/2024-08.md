何为一个函子呢？

既有操作又有数据

一个函子是否应该只有操作，而不应该有对应的状态

一个函子有其自身的属性

那应该有函子的实例化过程

函子名对应的是函子模板/生成器实体

在使用前一定会实例化

但有些函子是静态的，即无状态的，这和是否共享无关

只有一个操作节点的函子是无状态的

静态函子不是一个实体，没有其自身数据？

例如 from

子图中其实有很多节点

**操作节点/数据节点/函子节点（既有数据也有操作）/子图节点**

分别应该怎么表示？

纯操作节点/子图可以共享

那这样计算顺序就不能简单地以数据状态作为参考

因为计算节点没有自己的数据

除非将计算节点打包成一个函子

但这样是否会造成内存的浪费？

一个被大量频繁复用的函子，其实没有必要占据内存

那该怎样设计这个统一的节点模型呢？

每个节点至少要向外界表示自己的一个状态：已计算/未计算（是否就绪）

所以，计算图的节点必须包含是否就绪的内存占用，但它可拥有指向操作的指针

关键在于，如果其未就绪，那么应该做什么

也就是说，计算图的节点还应该指示，如果想使自己的状态又未就绪改为就绪，应该做什么工作

节点还应告知外界，在做这些工作之前，有哪些条件需要满足（所依赖的节点有哪些

虽然它所依赖的是节点，但本质上其以来的应该是数据

因为它自己的就绪状态需要拿到数据进行操作

也就是说，这里的节点，数据和操作缺一不可



在ONNX中，计算图的节点是算子，边是张量（数据）



这里面其实有 调度模型 和 存储模型 的区别

存储模型只需要考虑如何用最近凑的结构表达所有的信息

所以删掉了节点的状态信息，并把所有数据放在边上

其实，可以把这里的边理解为数据节点

因为只是表达DAG的话，只用边或者节点都是可以的

两种都用本质上还是在同时记录数据和操作



也许，计算图的计算状态应该由调度器负责维护，而不应该占用计算图的存储空间

调度器应该有权限选择哪些节点可以被跳过计算



# 2024年8月13日



ONNX使用边来表达输入输出给我带来了一定的启发

我觉得这很有效

可如果是多输入/输出呢？

比如，一个函子有一个返回值，但这个返回值被多个其他函子使用，该如何表示？

依赖关系可以复制，但边怎么复制呢



也许可以这样理解

一个计算节点只能输出唯一的数据

函子可以有多个返回值



可以明确的是

上层的函子/器件定义和底层的计算节点相差很多

函子只有一个输入和一个输出，但输入和输出都可能是一个列表



torch的计算图用了相反的表示

即节点表示变量，边表示运算

torch采用的是动态图，tensorflow采用的是静态图

为什么会有如此大的选择差异

我该选择什么样的表示方式呢



我最后的设计应该也是动态图模式（即时执行模式 eager execution）

但静态图更方便保存成文件，也便于进行图的优化和执行调度

那我可能是混合模式



还有一种选择就是混合节点，即节点既有可能代表数据，也有可能代表运算



好像，无论上层如何表示，计算图的底层表示都是以节点为主

节点需要记录的信息有，本节点对应的操作，本节点的输出（如果是常量则直接指定输出），本节点的状态（是否计算完毕）

以及

前驱节点或者后继节点（use_list）





关于函数函子对象的设计



如何构造一个可复用的子图？

关键在哪里？

子图结构的拷贝

数据节点的拷贝

子图重构造法性能恐怕很差