# 类型系统的设计

类型唯一ID？

参照JS，相同结构的类型为同一类型，还是参照C++，相同名称的类型才是同一类型

自定义类型只能通过名称，不是底层语言不能搞TS那一套

原子类型和组合类型

类型唯一ID要拓展

原子类型之间要提供转换方法

或者这样

基本类型、原子类型和组合类型

原子类型用命名空间名称作为唯一ID，这涉及到命名空间的实现

要有唯一实例（指针

哦对还有特殊类型

空值如何处理？错误如何处理？

函数类型如何处理？

还有any和null

这两个涉及到继承关系的设计

一个任意类型的变量可以被赋值为null吗，为什么

rust是显式地使用了Option类型

也就是说，null不应该是所有对象的基类，他们之间不存在继承关系，而只是一个特殊的包装

我们只是针对这个常用的包装提供一些额外的语法糖，仅此而已

另外要考虑的是，空检查对性能的影响如何

any本质上是绕过类型检查，要么要求所有对象都继承自某一基类，要么要求类型具有反射性

也就是说，参数为any，如果想要将其动态转化为某个类型就要反射，否则除非所有类共享某个方法，无法对其进行任何处理

camel不需要支持多类型动态赋值，因为它甚至都不鼓励变量

C++只是纯粹的自动类型推导

语法上参考dart的空安全设计，行为上参考rust的Option设计

dart：?/?./??/!/!.

type? === type | null

TS将null视为类型，所以支持这样的写法，camel严格将null定义为值，可空类型只能用相关语法

判断是否为空，需要传入的参数可以是任何对象但可能为空

可以设计match，基于值的判断

any包括空类型吗？

如果不支持any，那么print这个最常用的方法如何实现呢？

camel可以确保所有的类型的值都支持tostring

any类型可能需要保留

any类型不可以动态地转换为任意一种类型，所以无法用camel语言本身去操作any

只有inner函子才可以操作any

any类型可以被赋值为任意一种类型，包括空值

说白了，类型互相之间没有继承关系，但类型的值都继承自Value，any类型是为了方便针对于Value的操作而存在的

类型系统需要支持接口吗？需要，在不支持模板的前提下支持函数重载，这几乎是必选项

接口原来约束各值拥有共同的成员，但Camel弱化了成员的作用

Camel不是面向对象的，除了组合类型之外的类型没有成员

camel一般不会在语言层面构造一个类型具体的结构（这是一件好事么？

如同js和py，那只是字典/数据，它们共享同一个类型，要做区分吗？

经过针对性性能优化的dict其实很好用，把它和map区别对待是有重要意义的

但js和py中除了基本类型几乎一切皆dict

camel的接口设计总不能只考虑某种特定类型吧

dict理论上是可以动态添加成员的，这让针对dict的接口约束意义不大

dict只能是动态类型

其实，动态改变成员类型的行为属于修改行为，在camel中不被提倡，甚至可以直接禁掉

事实上在众多后端语言中这种行为都是被禁止的

而且dict和map要有足够的区分度，TS中obj可以通过.访问，camel某种意义上丧失了这种区分度

而把dict设计成不可变类型则刚好补足了这种区分度

dict的类型是可以根据值自动推导的，但也需要typeof关键字

这样，接口本身的设计就变成了partial的dict类型声明，它们之间可以进行计算，接口也属于组合类型

这意味着，只有dict才拥有共享成员的概念，不同类型之间可以取交集或并集

也就是说，原子类型和基本类型之间默认没有共同点，它们不会同时满足任何“接口”

考虑设计一个copy函数，如何签名才能表达其返回的dict所满足的接口恰好就是传入的dict所满足的接口呢？

需要typeof关键字吗

要抄TS的类型体操吗？

func copy<T>(obj: T): T {    return { ...obj }; }

dict要有对应的构造函数概念吗

另外类型实例化也需要进一步考虑

需要new关键字吗

对于实例化

实例化要考虑的问题是，变量初始赋值尽量避免设计成纯函数的形式

因为这隐含着以空值初始化并使用函数进行修改

基本类型：通过字面量实例化，且不可更改

原子类型（内置/拓展）：底层库提供macro new，位置默认为Type::new（类内成员）

组合类型：List/Dict字面量表达式实例化

字典类型/对象类型：字面量表达式实例化，或通过macro函数实例化

特殊类型（Any类型/函子类型：Any可以使用以上任意一种方法实力化（其实就两种，字面量或者macro func）

综上，对于现有的类型系统需要进行重构

类型就不要设计可以填数值了，这不是泛型

比如这种：Tensor<Type, [dim1, dim2]>

这其实是用类型代替了构造函数，会模糊泛型系统的设计，有时候也不知道传入的标识符是类型还是变量

那类似的需求应该怎么办呢？

其实这是个伪需求

显然，类型就应该是类型，一个具体的值不应该影响类型，其他的判断逻辑应该在内部完成



另外List/Dict/Tuple/Param不能直接作为类型，而必须指定成员类型，例如

```
List<String> // 或者写成 String[]
Dict<{ key: type... }> // 或者写成 { key: type... }
Tuple<Int, String, ...> // 或者写成 (type1, type2)
Param<{}/()>
```







要考虑一个问题

如果希望在执行完某一步之后print一个常量字符串该如何写？

其实可以这样写

```
->print<fmtstr> // 当fmtstr==null时退化为正常的print
```

也就是在没有参数上的数据依赖的前提下使其仍然等到某个节点执行完毕

换句话说，建立非参数数据依赖的执行依赖

这里不应该用wait，如果wait要求必须是sync函子的话

sync可以声明同步节点，也许也可以声明同步块

即：

```
sync {
	do sth
	print(conststr)
}
```

该块内默认按顺序执行，也即，每一行都会自动生成对上一行的非数据依赖关系

但它不是wait，所以不要求外层必须是sync

在sync块内部不必使用wait即可调用sync函数

sync函子和sync块不是同一个概念

sync函子是对外声明该函子要求将自己变为同步点，是对外的影响

sync块只是内部按顺序执行，不执行并发，是对内的影响

所以可以写出这样的函数：

```
sync func(): Void sync {

}
或者
sync () => sync {}
```

sync块定义不具有向内传递性，即在sync块内定义的函子的执行顺序仍然是异步的

泛型的写法

```
func(src: typeas T): T {}
typeof value is T
```

类型运算符

camel不使用关键字运算符，比如and or not等，也不会设计is not这种双关键字的运算符

camel引入is只用于类型判断

对于引用相等和值相等，camel采用\=\=和\=\=\=进行区分，其中\=\=\=代表引用相等，反之!\=\=代表引用不等

\=\=代表调用equal，不涉及隐式的类型转换

```
is // 类型完全相等
as // 类型标记（不涉及转换）只在编译前生效，只能处理可以safe转换的类型
```



新的操作符

```
let h = f..g // 链接

// 空安全
// typeExpr? | expr?
let a: Number? = null // Option<Number>
a?.map()
a?->func
a?..b
let b = a ?? ""
```



模式匹配

弃用三元表达式，统一用模式匹配代替，多写点代码没坏处

```
let res = match expr {
	case expr => expr
	case expr => sync {}
	case null => sth
	case _ => {}
}
```

支持if

```
let a = if cond then trueValue else falseValue
// 注意这里else是必须的，否则会出现返回值类型不确定的问题
```

暂时不支持for，因为for本质上在鼓励用户使用可变变量而不是用递归

支持列表推导式（python所证明的很好用的语法，很多函数式语言也拥有，或者说就是python学习的函数式语言）

这个要求支持迭代，需要额外考虑迭代器相关概念

这里其实就是要求C++类型声明接口，标记好类型的迭代器、序列化和反序列化、类型转换可行性判断、类型转换（至少包括to Bool类型）、构造方法、解包方法、类型成员函数（至少包含new方法）、拷贝构造函数、移动构造函数、析构函数、类型ID、哈希方法（可以throw error）、equals（对于这个需要考虑两种情况，一种是注册可以用于比较的类型，另一种是用户自定义的equal，因为要支持重载，这是对于可重载函数的处理方法）、泛型相关方法（泛型参数声明，具体就是接受其它类型的指针，但是要提供编译期方法（判断是否接受该类型）和运行时方法（决定具体的行为））

换句话说，接口分为三类：注册前、编译期、运行时

要提供一个内置函数，帮助开发者判断类型指针是否可以安全地转换为其期待的类型（注册的），这个需要类型ID系统匹配

camel为每一个原子类型（包括基础类型和特殊类型）生成一个运行时全局唯一ID（32位整数），其中，基本类型和特殊类型的ID早已确定，容器类型特殊处理。

剩下的camel维护一个注册表，维护开发者声明的ID（str）到全局唯一ID（TID）的映射

内置的tuple、dict、list是默认支持迭代的，其他的自定义类型该如何支持？其实可以直接在C++接口中实现

这里注意dict和tuple的结构是不可变的

```
[out_expr_res for out_expr in input_list if condition]
{ key_expr: value_expr for value in collection if condition }
(expression for item in Sequence if condition )
```

注意，在Camel中仅支持List的列表推导式，因为其他两种类型的结构是不可变的

列表切片语法

```
arr[::]
```

元素展开语法

```
{ ...{} }
[ ...[] ]
```

类型系统增强

支持enum

```
enum ident {
	a,
	b,
}
```

支持复数

```
`a + b i/j`
```

模块系统设计

或者说use的设计，还要考虑enum



再重申模块系统设计和use关键字的使用

途径：

- 导入包
- 命名空间/模块系统（module）
- 重命名

在每一个文档中应该写

```
module md_name // module declare 声明本文件
use module
use {} from module
module::member
use module
use module::member
export func
export let
export {}
Type::new
```

考虑不再使用路径，而使用::

使用路径有时无法防止用户倾向于使用绝对路径，而且路径的模式也不支持将多个文件自动视为同一个模块或者包

相对路径的问题就在于如何设置起始点

另外要考虑的是，import是动态的还是静态的

还要考虑的是，一个文件作为模块和作为起始点在行为上会有何不同，或者换句话说，如何指定起始点

camel是有编译概念的，是不会逐行动态执行和导入的

一个语言可以不需要入口函数指定，当且仅当其是逐行动态执行的

当入口文件唯一后，其实就不用考虑多入口带来的路径混乱问题了

考虑一个问题：是不是脚本必须是逐行执行的？天然异步的脚本还算是脚本吗？

是否要区分use和import

```
use a: Int32 = b as Int32
```

即便在编译期，use可以延迟考察，而import需要优先处理，为什么？

也许也不一定。只有module声明需要放在开头，剩下的其实就按顺序处理就好。你总不能强制要求用户把import写到最前面或者每次都要先遍历一下代码找到import吧。

模块概念还有一个好处，即在处理cache时可以把一个模块的所有东西存成一个文件，而不是每个文件都是一个cache

换句话说，模块内部是不可再分的

有时候js和py会有一个单独的文件（index.js/__init__.py）用于处理模块被导入时要进行的操作，或者进行统一的导入导出，camel需要吗？

camel不需要声明module main？不对。如果不声明module就无法访问到同module的代码。

但如果不写module，其实就不用遍历文件夹，开销会小一点，适合真正地脚本。

可以这样说，一个module内部只能有一个文件定义main，否则报错ident重定义。

不属于module的散件每个文件默认为一个module（名为其文件名），也就是每个文件可以有一个

作为执行点的module必须有一个main入口，不作为入口点的module的main会直接被忽视，不会报错

模块是一种非值的所属关系，另外还有类型的成员函数

对于这种所属关系，统一通过::访问

例如

```
import 'tf/nn'
use ones = nn::ones // use nn::ones
import { ones } from 'tf/nn'

export func f() {}
func main(): Int {} // Void也行，省略的默认为Void
```

注意，use和其他的关键字非常不同，它仅仅是一个编译期指令，用于添加符号映射

export/import不是stmt，不能写在函数块中，只能全局声明

export不是一个函子修饰符，而是一个语句修饰符，而sync可以是函子修饰符，所以不能写出下面的代码：

```
export let f = export func ...
```

模块还要考虑定位问题

在一个子文件夹下的某个模块如果想要访问外面的模块应该怎样做？

因为它外面的模块不在入口点为根所构建的体系中，所以它无法找到所引用的模块

无论是相对路径还是绝对路径（文件系统的路径），它都是绝对的

或者说，基于文件系统路径的模块中系统本质上是平摊的一维系统

但模块路径不一样，它和文件在系统路径没有直接地映射关系

包含在模块域内的所有节点的模块都可以通过从根目录开始寻找或者从本级目录开始寻找

如何表达向上层寻找的关系，rust是严格禁止这样做的

所以这本质上是树形结构和平面结构之争

> - 如果你追求 **简单性** 和 **高性能**，Go 的模块系统是一个不错的选择，并且它天然适合中大型项目的开发。
> - 如果你需要 **强类型检查** 和 **安全性**，Rust 的模块系统是更好的选择，尽管它的灵活性不如 JavaScript。
> - 如果你需要 **灵活性** 和 **动态加载**，JavaScript 的模块系统更胜一筹，但需要额外小心运行时可能出现的错误。

camel不要动态加载，但也不需要强制的限制

所以采用go的方案吧，用文件路径

go会禁止一个目录下有多个package的文件

camel会禁止显式声明多个module，但不禁止隐式声明的模块

默认目录下显示声明的模块会被认作该文件夹的模块

如果一个文件夹下没有显示声明模块的文件，则该文件夹不可被导入

```
import path // 等效于 import * from path，后面引用默认为该文件/目录所在模块名
import ident from path // 必须用ident::member，等效于 import * as ident from path
import {} from path // 只有导出的符号可见
export {}
use xx::yy // 等效于 use yy = xx::yy
```

