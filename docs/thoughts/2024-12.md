# 类型系统的设计

类型唯一ID？

参照JS，相同结构的类型为同一类型，还是参照C++，相同名称的类型才是同一类型

自定义类型只能通过名称，不是底层语言不能搞TS那一套

原子类型和组合类型

类型唯一ID要拓展

原子类型之间要提供转换方法

或者这样

基本类型、原子类型和组合类型

原子类型用命名空间名称作为唯一ID，这涉及到命名空间的实现

要有唯一实例（指针

哦对还有特殊类型

空值如何处理？错误如何处理？

函数类型如何处理？

还有any和null

这两个涉及到继承关系的设计

一个任意类型的变量可以被赋值为null吗，为什么

rust是显式地使用了Option类型

也就是说，null不应该是所有对象的基类，他们之间不存在继承关系，而只是一个特殊的包装

我们只是针对这个常用的包装提供一些额外的语法糖，仅此而已

另外要考虑的是，空检查对性能的影响如何

any本质上是绕过类型检查，要么要求所有对象都继承自某一基类，要么要求类型具有反射性

也就是说，参数为any，如果想要将其动态转化为某个类型就要反射，否则除非所有类共享某个方法，无法对其进行任何处理

camel不需要支持多类型动态赋值，因为它甚至都不鼓励变量

C++只是纯粹的自动类型推导

语法上参考dart的空安全设计，行为上参考rust的Option设计

dart：?/?./??/!/!.

type? === type | null

TS将null视为类型，所以支持这样的写法，camel严格将null定义为值，可空类型只能用相关语法

判断是否为空，需要传入的参数可以是任何对象但可能为空

可以设计match，基于值的判断

any包括空类型吗？

如果不支持any，那么print这个最常用的方法如何实现呢？

camel可以确保所有的类型的值都支持tostring

any类型可能需要保留

any类型不可以动态地转换为任意一种类型，所以无法用camel语言本身去操作any

只有inner函子才可以操作any

any类型可以被赋值为任意一种类型，包括空值

说白了，类型互相之间没有继承关系，但类型的值都继承自Value，any类型是为了方便针对于Value的操作而存在的

类型系统需要支持接口吗？需要，在不支持模板的前提下支持函数重载，这几乎是必选项

接口原来约束各值拥有共同的成员，但Camel弱化了成员的作用

Camel不是面向对象的，除了组合类型之外的类型没有成员

camel一般不会在语言层面构造一个类型具体的结构（这是一件好事么？

如同js和py，那只是字典/数据，它们共享同一个类型，要做区分吗？

经过针对性性能优化的dict其实很好用，把它和map区别对待是有重要意义的

但js和py中除了基本类型几乎一切皆dict

camel的接口设计总不能只考虑某种特定类型吧

dict理论上是可以动态添加成员的，这让针对dict的接口约束意义不大

dict只能是动态类型

其实，动态改变成员类型的行为属于修改行为，在camel中不被提倡，甚至可以直接禁掉

事实上在众多后端语言中这种行为都是被禁止的

而且dict和map要有足够的区分度，TS中obj可以通过.访问，camel某种意义上丧失了这种区分度

而把dict设计成不可变类型则刚好补足了这种区分度

dict的类型是可以根据值自动推导的，但也需要typeof关键字

这样，接口本身的设计就变成了partial的dict类型声明，它们之间可以进行计算，接口也属于组合类型

这意味着，只有dict才拥有共享成员的概念，不同类型之间可以取交集或并集

也就是说，原子类型和基本类型之间默认没有共同点，它们不会同时满足任何“接口”

考虑设计一个copy函数，如何签名才能表达其返回的dict所满足的接口恰好就是传入的dict所满足的接口呢？

需要typeof关键字吗

要抄TS的类型体操吗？

func copy<T>(obj: T): T {    return { ...obj }; }

dict要有对应的构造函数概念吗

另外类型实例化也需要进一步考虑

需要new关键字吗

对于实例化

实例化要考虑的问题是，变量初始赋值尽量避免设计成纯函数的形式

因为这隐含着以空值初始化并使用函数进行修改

基本类型：通过字面量实例化，且不可更改

原子类型（内置/拓展）：底层库提供macro new，位置默认为Type::new（类内成员）

组合类型：List/Dict字面量表达式实例化

字典类型/对象类型：字面量表达式实例化，或通过macro函数实例化

特殊类型（Any类型/函子类型：Any可以使用以上任意一种方法实力化（其实就两种，字面量或者macro func）

综上，对于现有的类型系统需要进行重构

类型就不要设计可以填数值了，这不是泛型

比如这种：Tensor<Type, [dim1, dim2]>

这其实是用类型代替了构造函数，会模糊泛型系统的设计，有时候也不知道传入的标识符是类型还是变量

那类似的需求应该怎么办呢？

其实这是个伪需求

显然，类型就应该是类型，一个具体的值不应该影响类型，其他的判断逻辑应该在内部完成



另外List/Dict/Tuple/Param不能直接作为类型，而必须指定成员类型，例如

```
List<String> // 或者写成 String[]
Dict<{ key: type... }> // 或者写成 { key: type... }
Tuple<Int, String, ...> // 或者写成 (type1, type2)
Param<{}/()>
```







要考虑一个问题

如果希望在执行完某一步之后print一个常量字符串该如何写？

其实可以这样写

```
->print<fmtstr> // 当fmtstr==null时退化为正常的print
```

也就是在没有参数上的数据依赖的前提下使其仍然等到某个节点执行完毕

换句话说，建立非参数数据依赖的执行依赖

这里不应该用wait，如果wait要求必须是sync函子的话

sync可以声明同步节点，也许也可以声明同步块

即：

```
sync {
	do sth
	print(conststr)
}
```

该块内默认按顺序执行，也即，每一行都会自动生成对上一行的非数据依赖关系

但它不是wait，所以不要求外层必须是sync

在sync块内部不必使用wait即可调用sync函数

sync函子和sync块不是同一个概念

sync函子是对外声明该函子要求将自己变为同步点，是对外的影响

sync块只是内部按顺序执行，不执行并发，是对内的影响

所以可以写出这样的函数：

```
sync func(): Void sync {

}
或者
sync () => sync {}
```

sync块定义不具有向内传递性，即在sync块内定义的函子的执行顺序仍然是异步的

泛型的写法

```
func(src: typeas T): T {}
typeof value is T
```

类型运算符

camel不使用关键字运算符，比如and or not等，也不会设计is not这种双关键字的运算符

camel引入is只用于类型判断

对于引用相等和值相等，camel采用\=\=和\=\=\=进行区分，其中\=\=\=代表引用相等，反之!\=\=代表引用不等

\=\=代表调用equal，不涉及隐式的类型转换

```
is // 类型完全相等
as // 类型标记（不涉及转换）只在编译前生效，只能处理可以safe转换的类型
```



新的操作符

```
let h = f..g // 链接

// 空安全
// typeExpr? | expr?
let a: Number? = null // Option<Number>
a?.map()
a?->func
a?..b
let b = a ?? ""
```



模式匹配

弃用三元表达式，统一用模式匹配代替，多写点代码没坏处

```
let res = match expr {
	case expr => expr
	case expr => sync {}
	case null => sth
	case _ => {}
}
```

支持if

```
let a = if cond then trueValue else falseValue
// 注意这里else是必须的，否则会出现返回值类型不确定的问题
```

暂时不支持for，因为for本质上在鼓励用户使用可变变量而不是用递归

Camel同许多函数式语言一样，是函数优先、**表达式优先**的，if和match甚至包括block都是表达式，是有默认返回值的。

支持列表推导式（python所证明的很好用的语法，很多函数式语言也拥有，或者说就是python学习的函数式语言）

这个要求支持迭代，需要额外考虑迭代器相关概念

这里其实就是要求C++类型声明接口，标记好类型的迭代器、序列化和反序列化、类型转换可行性判断、类型转换（至少包括to Bool类型）、构造方法、解包方法、类型成员函数（至少包含new方法）、拷贝构造函数、移动构造函数、析构函数、类型ID、哈希方法（可以throw error）、equals（对于这个需要考虑两种情况，一种是注册可以用于比较的类型，另一种是用户自定义的equal，因为要支持重载，这是对于可重载函数的处理方法）、泛型相关方法（泛型参数声明，具体就是接受其它类型的指针，但是要提供编译期方法（判断是否接受该类型）和运行时方法（决定具体的行为））

换句话说，接口分为三类：注册前、编译期、运行时

要提供一个内置函数，帮助开发者判断类型指针是否可以安全地转换为其期待的类型（注册的），这个需要类型ID系统匹配

camel为每一个原子类型（包括基础类型和特殊类型）生成一个运行时全局唯一ID（32位整数），其中，基本类型和特殊类型的ID早已确定，容器类型特殊处理。

剩下的camel维护一个注册表，维护开发者声明的ID（str）到全局唯一ID（TID）的映射

内置的tuple、dict、list是默认支持迭代的，其他的自定义类型该如何支持？其实可以直接在C++接口中实现

这里注意dict和tuple的结构是不可变的

```
[out_expr_res for out_expr in input_list if condition]
{ key_expr: value_expr for value in collection if condition }
(expression for item in Sequence if condition )
```

注意，在Camel中仅支持List的列表推导式，因为其他两种类型的结构是不可变的

列表切片语法

```
arr[::]
```

元素展开语法

```
{ ...{} }
[ ...[] ]
```

类型系统增强

支持enum

```
enum ident {
	a,
	b,
}
```

支持复数

```
`a + b i/j`
```

模块系统设计

或者说use的设计，还要考虑enum



再重申模块系统设计和use关键字的使用

途径：

- 导入包
- 命名空间/模块系统（module）
- 重命名

在每一个文档中应该写

```
module md_name // module declare 声明本文件
use module
use {} from module
module::member
use module
use module::member
export func
export let
export {}
Type::new
```

考虑不再使用路径，而使用::

使用路径有时无法防止用户倾向于使用绝对路径，而且路径的模式也不支持将多个文件自动视为同一个模块或者包

相对路径的问题就在于如何设置起始点

另外要考虑的是，import是动态的还是静态的

还要考虑的是，一个文件作为模块和作为起始点在行为上会有何不同，或者换句话说，如何指定起始点

camel是有编译概念的，是不会逐行动态执行和导入的

一个语言可以不需要入口函数指定，当且仅当其是逐行动态执行的

当入口文件唯一后，其实就不用考虑多入口带来的路径混乱问题了

考虑一个问题：是不是脚本必须是逐行执行的？天然异步的脚本还算是脚本吗？

是否要区分use和import

```
use a: Int32 = b as Int32
```

即便在编译期，use可以延迟考察，而import需要优先处理，为什么？

也许也不一定。只有module声明需要放在开头，剩下的其实就按顺序处理就好。你总不能强制要求用户把import写到最前面或者每次都要先遍历一下代码找到import吧。

模块概念还有一个好处，即在处理cache时可以把一个模块的所有东西存成一个文件，而不是每个文件都是一个cache

换句话说，模块内部是不可再分的

有时候js和py会有一个单独的文件（index.js/__init__.py）用于处理模块被导入时要进行的操作，或者进行统一的导入导出，camel需要吗？

camel不需要声明module main？不对。如果不声明module就无法访问到同module的代码。

但如果不写module，其实就不用遍历文件夹，开销会小一点，适合真正地脚本。

可以这样说，一个module内部只能有一个文件定义main，否则报错ident重定义。

不属于module的散件每个文件默认为一个module（名为其文件名），也就是每个文件可以有一个

作为执行点的module必须有一个main入口，不作为入口点的module的main会直接被忽视，不会报错

模块是一种非值的所属关系，另外还有类型的成员函数

对于这种所属关系，统一通过::访问

例如

```
import 'tf/nn'
use ones = nn::ones // use nn::ones
import { ones } from 'tf/nn'

export func f() {}
func main(): Int {} // Void也行，省略的默认为Void
```

注意，use和其他的关键字非常不同，它仅仅是一个编译期指令，用于添加符号映射

export/import不是stmt，不能写在函数块中，只能全局声明

export不是一个函子修饰符，而是一个语句修饰符，而sync可以是函子修饰符，所以不能写出下面的代码：

```
export let f = export func ...
```

模块还要考虑定位问题

在一个子文件夹下的某个模块如果想要访问外面的模块应该怎样做？

因为它外面的模块不在入口点为根所构建的体系中，所以它无法找到所引用的模块

无论是相对路径还是绝对路径（文件系统的路径），它都是绝对的

或者说，基于文件系统路径的模块中系统本质上是平摊的一维系统

但模块路径不一样，它和文件在系统路径没有直接地映射关系

包含在模块域内的所有节点的模块都可以通过从根目录开始寻找或者从本级目录开始寻找

如何表达向上层寻找的关系，rust是严格禁止这样做的

所以这本质上是树形结构和平面结构之争

> - 如果你追求 **简单性** 和 **高性能**，Go 的模块系统是一个不错的选择，并且它天然适合中大型项目的开发。
> - 如果你需要 **强类型检查** 和 **安全性**，Rust 的模块系统是更好的选择，尽管它的灵活性不如 JavaScript。
> - 如果你需要 **灵活性** 和 **动态加载**，JavaScript 的模块系统更胜一筹，但需要额外小心运行时可能出现的错误。

camel不要动态加载，但也不需要强制的限制

所以采用go的方案吧，用文件路径

go会禁止一个目录下有多个package的文件

camel会禁止显式声明多个module，但不禁止隐式声明的模块

默认目录下显示声明的模块会被认作该文件夹的模块

如果一个文件夹下没有显示声明模块的文件，则该文件夹不可被导入

```
import path // 等效于 import * from path，后面引用默认为该文件/目录所在模块名
import ident from path // 必须用ident::member，等效于 import * as ident from path
import {} from path // 只有导出的符号可见
export {}
use xx::yy // 等效于 use yy = xx::yy
```





### 关于类型系统的进一步思考

代数类型系统

Struct/Object其实就是积类型，即某个类型必须包含所有声明的字段，这个在Camel中就对应Dict类型。

积类型（TypeA * TypeB）其实有多种表达形式：

```
Dict: { a: TypeA, b: TypeB }
Tuple: (TypeA, TypeB)
```

许多语言的enum其实就是和类型，即某个类型接纳所有子类型，这个在Camel中就对应Union类型。

与常规Enum不同的是，Enum的成员通常被当作值使用，且经典语言的Enum并不允许子成员各自是不同的类型，更不用说泛型。

但是rust的enum提供了更灵活的支持。而常见的函数式语言，包括TS，则是采用了|运算符来表达和类型。

从实践来看，一个既能容纳值，也能容纳类型的和类型，及其对应的模式匹配其实是非常有用的。

在rust中Bool就是一个和类型：
```
enum Bool {
	True,
	False
}
```

ADT非常适合构造树状结构，比如Rust中的JSON格式：

```
enum JsonValue {
    Bool(bool),
    Int(i64),
    String(String),
    Array(Vec<JsonValue>),
    Map(HashMap<String, JsonValue>),
}
```



和类型

关于类型运算

联合类型之间也可以用 & | 进行运算

TS中的联合类型其实就是一种增强的联合类型和枚举类型的结合

TS允许在联合类型中掺入基本类型：
```
type a = 'e' | Type
```



模式匹配

Rust 是一门系统编程语言，但它也汲取了许多函数式编程语言（如 Haskell、Scala 等）的特性，设计理念非常先进，简洁而又现代化。

（简洁，不多说，现代化要足够好用，go属于简洁但太复古，不好用）

它的模式匹配还支持解构绑定，非常强大，一定要学习。



联合类型

类型守卫与类型断言

当联合类型想要作为某个具体的类型使用时，可以使用类型守卫：

```
if val is T then {} else {}
// 或者
match val {
	case T => {}
	case _ => {}
}
```

也可以使用类型断言



ADT设计导向下的接口如何实现？（impl/extends？）





## 关于异常处理

异常需要是可恢复的

Rust会使用Result，官方暂时不支持trycatch，但是会有一些社区版的实现（利用rust强大的宏）

camel应该提供原生的try catch  finally，但是要考虑和graph的对接，以及异步的兼容性

rust不提供捕获运行时错误的机制，go也倾向于panic

Result是内置的类型，但其实不是关键字，但这样的好处是称为事实标准，以便标准库的拓展。

rust中的try是自动返回Result的块，简化Result的写法，自动处理中间表达式返回的Err并返回

```
```

你要想一个问题，即空安全和错误机制某种程度上是有重合的

如果对空安全采用大量的语法糖，那么就等同于鼓励用户用空代表错误，而有的人则用，这会造成社区的分裂

Camel也许不适合隐式的错误处理，一方面是与底层Graph不能很好的兼容，另一方面这种处理方式也不符合更现代语言的设计哲学

隐式异常机制意味着错误的传播路径是隐式的和动态的，虽然使得代码更简洁灵活，

但会导致开发者难以清楚地知道哪些方法会抛出错误，需要依赖文档和自动追溯工具，甚至是语法的约束标记，最后也没有省事

有时也会导致开发者忽略掉可能抛出的异常，从而发生运行时崩溃

对异常的捕获会带来额外的设计冗余和运行时开销



其实在Camel中，一个块就是一个子图，而不一定非得是明确定义的函数

Camel即使想要实现错误捕获，也是在子图的层级完成的，借助C++是可以实现的



所以现在的问题归结于，究竟要显式的还是隐式的错误处理机制？

显式的错误处理有诸多好处，原则上依此设计，但要提供语法糖以简化写法



在Rust中，Option和Result是非常基础的类型

Option拥有Some和None，Result拥有Ok和Err，这些都是基于enum设计的，我想用运算符表达

```
// 在Camel中 Option<T> 等效于 T?，Result<T, E> 等效于 T ? E
```

rust还提供unwrap和expect，其实等效于

```
a.unwarp() ==> a! // 断言失败会panic
a.unwrap_or(val) ==> a ?? val
// expect 怎么办？即当为异常值时返回指定异常值
// 类似呗：
a.expect(msg) ==> a !! msg
// 在camel中try块可以自动捕获并返回Result
```

还有一个问题，如果try内有多种报错源且错误类型不一样怎么办？或者换句话说，try块返回的Result的错误类型是如何确定的？

其实上面的代码本质上就是错误得到了处理。rust中的try块是基于用户不想每次处理而实现的

rust会隐式的推断类型，包括尝试转换为更通用的类型，以及产生编译期报错

其实如果camel拥有更好的错误处理语法糖，其实就不需要try块来处理常规的错误，而可以用来捕获panic

camel的错误处理语法足够好了吗？如果用户想要透明地返回出现的错误呢？就是说，不用！！覆盖，而是返回其错误

那这个就必须要显式处理了，因为这样必然会导致返回类型可能不一致的问题，所以需要显式地处理

camel如何显式地返回一个错误？throw

在camel中，return、throw和panic都是块跳出语句，都可以返回值，但机制不同

throw还是raise？throw暗示了catch的存在。panic后面跟随value会显得有点奇怪。

camel可以引入try/catch/throw/finally用于实现类似对panic的处理，但在日常各类错误处理时更推崇可恢复的错误，即raise

camel反对滥用throw，建议做好类型检查



在camel中?.之类的运算符可以在值异常时返回对应的异常值（空或者Err），如果使用!.则会直接panic



如何显式返回错误？rust可以直接Err(val)，camel可以直接throw吗？

rust这里只是一个返回enum的某个值的写法，throw可以作为一个语法糖，比如：

```
raise val ==> return Result::Err::new(val)
```

这引入了一个问题，rust的设计和enum的设计实现了逻辑闭环，如果要这样做，camel的模式匹配该如何设计？enum又该如何设计？





还有一个问题，错误处理如何恢复？这个主要涉及到资源的释放，其实可以实现RAII，要求扩展原子类型主动实现析构函数。

Camel的GC要及时的调用析构函数。

camel中数组越界怎么办？这么常用的总不能用Result包裹吧，不然每次都要加！

所以必须有panic机制。越界直接崩溃

panic不仅仅意味着终止，而是意味着安全地终止，也就是说会自动处理掉所有的未释放资源。这是为了稳健性考虑的。

panic是具备线程隔离性的。在camel中暂时没有线程的概念，先不管。

未经处理的error是无法通过编译的，因为有静态类型检查，Camel要求用户必须显式处理错误

而对于一些发生不常见的，但场景过于常见以至于会带来额外累赘的，比如数组越界和除零问题，系统直接panic

但为了系统的稳定性，panic也需要某种catch机制

问题暂时已解决。



关于类型推导。

Any本质上是一种逃逸机制，适用于不追求完全的类型安全的动态类型语言。Camel不适用。但由于Camel在设计上仅仅是一个前端语言，而后端测操作空间极大，信息极为丰富，因此可以允许Any的存在，但只允许内部函子使用Any类型。

关于类型推导的理论基础：

> ####  1. **Hindley-Milner 类型系统**
>
> - **核心思想**：Hindley-Milner（HM）类型系统是自动类型推导的经典理论基础，最初由 Roger Hindley 和 Robin Milner提出，广泛应用于许多函数式编程语言（如 Haskell、OCaml、ML）。
>
> - 主要特性
>
>   ：
>
>   - 类型推导基于λ演算和多态类型。
>   - HM 类型系统通过 **合一算法（Unification Algorithm）**，能够在多态系统中无须显式类型注解，推导出程序中所有表达式的最一般类型（Principal Type）。
>   - HM 系统具有 **完备性和决定性**：它能够保证能够推导出所有类型正确的表达式的类型，且推导结果唯一。
>
> - **局限性**：HM 类型系统难以处理复杂的类型特性，比如子类型、多态约束、依赖类型等。
>
> #### 2. **类型约束求解（Type Constraint Solving）**
>
> - 类型推导可以被视为一个
>
>    
>
>   约束求解问题
>
>   ：
>
>   - 编译器通过分析程序生成一组类型约束（Type Constraints）；
>   - 然后通过算法（如合一、约束求解或 SAT 求解）来解决这些约束，从而推导出类型。
>
> - 这一理论适用于更复杂的类型系统（如带有泛型、特征、子类型、多态约束的语言），并为现代语言（如 Rust 和 Scala）的类型推导奠定了理论基础。
>
> #### 3. **依赖类型（Dependent Types）**
>
> - 在依赖类型系统中，类型可以依赖于值（例如，数组的长度可以是类型的一部分）。
> - 自动类型推导在依赖类型中变得更加复杂，通常需要更强的理论工具（如定理证明、逻辑约束求解器）来处理。
> - Coq、Agda 等依赖类型语言中的类型推导依赖于更高层次的理论指导。



接口如何实现？

其实接口最重要的就是面向Dict类型，就是要求某个传入的Dict拥有某个类型

其实，这个可以隐式地完成，只要传入的类型包含声明的类型，就可以被安全地隐式转换



回到主线，ADT和enum语法的设计，以及接口与实现的思考。

ADT有一些局限性，但这对于Camel并不重要。Camel并不是设计用于仅使用前端（即语法自身）来实现图灵完备，以表达诸多复杂的数据结构。它不需要做到对足够原子化的值、类型及其组成的极为繁杂的结构的支持。它将这些留作外界依赖去解决。所以他不需要对lambda演算相关的理论有很好的支持。

enum其实就是有命名的联合语法

所以有两种方案，统一采用enum，参考rust，或者增强联合运算符，即支持指定名字

```
type Expr = Const of T | Add of (Expr, Expr)
```

如果引入了联合运算符，那该把Option和Result视为Union的特例吗？

不可以，Option和Result有单独的声明方法（?/??），以及单独的返回语句raise，它是内置原子泛型，要参与优化，不可以与用户定义的联合类型视作同一种东西

Union类型有两个禁忌，其一，元素类型不可为空（Void），其二，元素类型不可以有重复

注意要和类型断言可以兼容。

这样的设计是可以的，只是这是不同类型的联合类型，其实还缺乏同类型的不同值的枚举。那就直接用枚举呗。

```
enum Status of Int = {
	OK: 200,
}
```

match如何设计？

```
match expr {
	case 
}
```





命名联合类型 {}，匿名联合类型 | 

Option<>和Result<>是什么类型呢？

```
Option<T> ==> T? ==> T | Void
Result<T, E> ==> T ? E ==> T | E
// 这里就不需要泛型了，泛型主要用于其他原子类型的能力拓展
```





rust教程里提到了一个有用的概念PRECLUDE

相比于include，preclude是指非常有用的库支持，但不需要显式的引入。这很好。
