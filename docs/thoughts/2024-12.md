# 类型系统的设计

类型唯一ID？

参照JS，相同结构的类型为同一类型，还是参照C++，相同名称的类型才是同一类型

自定义类型只能通过名称，不是底层语言不能搞TS那一套

原子类型和组合类型

类型唯一ID要拓展

原子类型之间要提供转换方法

或者这样

基本类型、原子类型和组合类型

原子类型用命名空间名称作为唯一ID，这涉及到命名空间的实现

要有唯一实例（指针

哦对还有特殊类型

空值如何处理？错误如何处理？

函数类型如何处理？

还有any和null

这两个涉及到继承关系的设计

一个任意类型的变量可以被赋值为null吗，为什么

rust是显式地使用了Option类型

也就是说，null不应该是所有对象的基类，他们之间不存在继承关系，而只是一个特殊的包装

我们只是针对这个常用的包装提供一些额外的语法糖，仅此而已

另外要考虑的是，空检查对性能的影响如何

any本质上是绕过类型检查，要么要求所有对象都继承自某一基类，要么要求类型具有反射性

也就是说，参数为any，如果想要将其动态转化为某个类型就要反射，否则除非所有类共享某个方法，无法对其进行任何处理

camel不需要支持多类型动态赋值，因为它甚至都不鼓励变量

C++只是纯粹的自动类型推导

语法上参考dart的空安全设计，行为上参考rust的Option设计

dart：?/?./??/!/!.

type? === type | null

TS将null视为类型，所以支持这样的写法，camel严格将null定义为值，可空类型只能用相关语法

判断是否为空，需要传入的参数可以是任何对象但可能为空

可以设计match，基于值的判断

any包括空类型吗？

如果不支持any，那么print这个最常用的方法如何实现呢？

camel可以确保所有的类型的值都支持tostring

any类型可能需要保留

any类型不可以动态地转换为任意一种类型，所以无法用camel语言本身去操作any

只有inner函子才可以操作any

any类型可以被赋值为任意一种类型，包括空值

说白了，类型互相之间没有继承关系，但类型的值都继承自Value，any类型是为了方便针对于Value的操作而存在的

类型系统需要支持接口吗？需要，在不支持模板的前提下支持函数重载，这几乎是必选项

接口原来约束各值拥有共同的成员，但Camel弱化了成员的作用

Camel不是面向对象的，除了组合类型之外的类型没有成员

camel一般不会在语言层面构造一个类型具体的结构（这是一件好事么？

如同js和py，那只是字典/数据，它们共享同一个类型，要做区分吗？

经过针对性性能优化的dict其实很好用，把它和map区别对待是有重要意义的

但js和py中除了基本类型几乎一切皆dict

camel的接口设计总不能只考虑某种特定类型吧

dict理论上是可以动态添加成员的，这让针对dict的接口约束意义不大

dict只能是动态类型

其实，动态改变成员类型的行为属于修改行为，在camel中不被提倡，甚至可以直接禁掉

事实上在众多后端语言中这种行为都是被禁止的

而且dict和map要有足够的区分度，TS中obj可以通过.访问，camel某种意义上丧失了这种区分度

而把dict设计成不可变类型则刚好补足了这种区分度

dict的类型是可以根据值自动推导的，但也需要typeof关键字

这样，接口本身的设计就变成了partial的dict类型声明，它们之间可以进行计算，接口也属于组合类型

这意味着，只有dict才拥有共享成员的概念，不同类型之间可以取交集或并集

也就是说，原子类型和基本类型之间默认没有共同点，它们不会同时满足任何“接口”

考虑设计一个copy函数，如何签名才能表达其返回的dict所满足的接口恰好就是传入的dict所满足的接口呢？

需要typeof关键字吗

要抄TS的类型体操吗？

func copy<T>(obj: T): T {    return { ...obj }; }

dict要有对应的构造函数概念吗

另外类型实例化也需要进一步考虑

需要new关键字吗

对于实例化

实例化要考虑的问题是，变量初始赋值尽量避免设计成纯函数的形式

因为这隐含着以空值初始化并使用函数进行修改

基本类型：通过字面量实例化，且不可更改

原子类型（内置/拓展）：底层库提供macro new，位置默认为Type::new（类内成员）

组合类型：List/Dict字面量表达式实例化

字典类型/对象类型：字面量表达式实例化，或通过macro函数实例化

特殊类型（Any类型/函子类型：Any可以使用以上任意一种方法实力化（其实就两种，字面量或者macro func）

综上，对于现有的类型系统需要进行重构

类型就不要设计可以填数值了，这不是泛型

比如这种：Tensor<Type, [dim1, dim2]>

这其实是用类型代替了构造函数，会模糊泛型系统的设计，有时候也不知道传入的标识符是类型还是变量

那类似的需求应该怎么办呢？

其实这是个伪需求

显然，类型就应该是类型，一个具体的值不应该影响类型，其他的判断逻辑应该在内部完成





要考虑一个问题

如果希望在执行完某一步之后print一个常量字符串该如何写？

也就是在没有参数上的数据依赖的前提下使其仍然等到某个节点执行完毕

换句话说，建立非参数数据依赖的执行依赖

这里不应该用wait，如果wait要求必须是sync函子的话

sync可以声明同步节点，也许也可以声明同步块

即：

```
sync {
	do sth
	print(conststr)
}
```

该块内默认按顺序执行，也即，每一行都会自动生成对上一行的非数据依赖关系

但它不是wait，所以不要求外层必须是sync

在sync块内部不必使用wait即可调用sync函数

sync函子和sync块不是同一个概念

sync函子是对外声明该函子要求将自己变为同步点，是对外的影响

sync块只是内部按顺序执行，不执行并发，是对内的影响

所以可以写出这样的函数：

```
sync func(): Void sync {

}
或者
sync () => sync {}
```

sync块定义不具有向内传递性，即在sync块内定义的函子的执行顺序仍然是异步的
