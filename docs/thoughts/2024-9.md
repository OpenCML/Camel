可能向函数式编程语言全面转型



原来的定位是基于DAG的通用DSL框架



现在定位是基于函数式思想的ML前端脚本语言

要可优化

要ML导向



经典的函数式编程语言

OCaml/Haskell/Scheme(Lisp)/Scala



静态类型检查太诱人了

性能优化、安全检查、函数重载



实体链本质上是为了方便DSL开发者创建更好的表达

但对于AI领域来说，弊大于利

其动态性太强了，无法做类型推断，无法做展开优化，甚至其语法结构对分号有强依赖，不利于parser优化，其空格表达式的结构也妨碍了许多字面量语法

利用其实现if/for/from，一方面不如引入新的关键字以实现更好的优化，另一方面if/for与函数式语言的基本习惯相违背，

其实也没有必要为一种效果提供多种写法

总之是一个比较无聊的设计



## 2024年9月9日

思考大致有了一些结论

1、对于实体链语法的问题

这本质上是一个是否采用一个高动态的概念的问题，实体链的执行过程难以进行静态分析，不利于进行静态优化，也不利于做LSP辅助，它的主要优势是可以为DSL开发者提供强大的表达能力（类似Lisp思想），但如果想要针对AI领域有所作为则会在性能、安全和易用性上带来较大缺陷。所以该问题从根本上是用户群体取向问题，即究竟是面向无数小领域的DSL开发者还是面向未来前景如火如荼地AI大领域从业者的问题。

最终决定移除该特性。

移除该特性后，可以引入一些曾经因语法分析困难而舍弃的特性，比如一些字面量的表达式。

另外，需引入import from语法。

2、对于赋值操作的支持问题

单纯的赋值操作会在底层的计算图中引入环路，使其不再成为一个有向无环图，这与语言的核心定位发生了冲突。但赋值操作又是众多语言的公有特性，即便是很多纯函数式语言，也在某种程度上放开了对数据修改的支持。事实上，即便不支持赋值，也无法避免底层函子在框架级别对数据进行修改，这是便利性和高效性的必然需要。另外，想要支持AI模型训练，就必然离不开对状态和参数的修改，以及对分支和循环的支持。所以，必须找出一种既支持数据动态修改也不至于底层变成有环图的方案。

深入考察这个问题的本质，其实在于一个数据节点的依赖节点对齐数据在不同时段的依赖问题。有些后继节点可能需要该数据的初始版本，而有些后继节点可能需要该数据的最新版本。在有向无环图的调度中，不同节点之间调度的时间先后顺序本来仅取决于节点之间的数据依赖关系，而没有在代码中书写的先后之分。但不同节点在代码中声明的顺序其实隐含了其对于某个公共数据的依赖顺序。假设有以下代码：

```
let a = 1;
print(a); // a->print
a = a + 1; // [a, 1]->plus->a
print(a); // a->print
```

可见，当第三行代码对a进行修改之后，该行之后的所有代码在语义上应该依赖的是最新版本的a。因此，可以对现有的语言做如下修改：

- 显式追踪所有可能修改变量的操作，并要求用户显式标记其所在的行。
  - 引入var关键字，用于修饰变量和函数参数，便于编译器追踪分析对变量的修改操作。
  - 引入wait关键字，后跟可能产生副作用的表达式，用于划分被影响的变量的版本。
- 以wait划分的代码为界，将其下的代码对源数据的依赖转移到新的数据节点，并将该节点的前置条件设为有副作用的操作节点。
  - 引入新的节点类型，WAITNODE，其输入，一个是副作用节点，另一个是原数据节点。

```
var a = 1;
print(a); // a->print
wait a = a + 1; // [a, 1]->plus->a1
print(a); // a1->print

func test(a: Int) {}
func test(var a: Int) {}
```



## 2024年9月18日

1、关于与SPL（Stream Processing Language）的关系的思考

OpenCML与SPL的定位其实有很大不同

- CML不支持流，SPL为流打造
- CML是中心化调度的，SPL是去中心化、分布式的
- CML同一个线程可以执行多个节点，SPL每个节点都代表一个隔离机器

2、关于函子输入输出行为规范的思考

目前函子是单输入、单输出的，后面要经过多遍图优化才能展开，而包含递归的函子是不能展开的（即需要是ATOMIC的）

但这里有一个关键问题，有时候我们只想给一个参数，或者直接拿到一个输出，并不想手动再封装一次列表或者解包一次列表，这会带来一些不清晰的问题。

对于返回值这个问题比较好解决，因为返回值可以明确声明返回类型是一个列表，或者是元组，因为返回值只有一个。

可以规定函数参数也只有一个，即Param类型，而PARAM类型可以被LIST类型、TUPLE类型甚至是DICT类型赋值，但我还希望其可以被单变量赋值。这里有一个问题在于，单变量本身也可能是LIST或者TUPLE，这要求PARAM可以根据单变量的具体类型进行自动展开。还好的是，目前对CML的定位是静态强类型语言，这样做也许不会有太多麻烦，但总会引入一些复杂展开规则，这可能成为后面的雷点。

而且还要考虑的是，即使单变量本身是一个可展开对象，但如果开发者不希望触发PARAM的自动展开，就必须有一些手段阻止，其实一个可行的办法是在外层套一个匿名列表，以避免自动展开。

```
[[], ]
```

3、关于内置特殊数据结构字面量语法的思考

对于内置的结构化数据结构最好应该有字面量初始化语法，原因如下：

- 数据结构需要初始化，由于不支持泛型模板参数所以不建议使用构造函子做初始化
- 崇尚不可变数据，一般不会出现逻辑构造，所以字面量结构化构造是最为简洁的方式

对于同构结构化数据，在初始化时需要指定元素类型，所以这并不是换不同的括号的问题，而是需要类型模板参数的问题

后面需要针对类型系统作进一步优化