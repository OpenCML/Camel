## 2024年9月1日

可能向函数式编程语言全面转型。

原来的定位是基于DAG的通用DSL框架，现在定位是基于函数式思想的ML前端脚本语言。

要可优化

要ML导向

经典的函数式编程语言

OCaml/Haskell/Scheme(Lisp)/Scala

静态类型检查太诱人了

性能优化、安全检查、函数重载

实体链本质上是为了方便DSL开发者创建更好的表达

但对于AI领域来说，弊大于利

其动态性太强了，无法做类型推断，无法做展开优化，甚至其语法结构对分号有强依赖，不利于parser优化，其空格表达式的结构也妨碍了许多字面量语法

利用其实现if/for/from，一方面不如引入新的关键字以实现更好的优化，另一方面if/for与函数式语言的基本习惯相违背，

其实也没有必要为一种效果提供多种写法

总之是一个比较无聊的设计



## 2024年9月9日

思考大致有了一些结论

1、对于实体链语法的问题

这本质上是一个是否采用一个高动态的概念的问题，实体链的执行过程难以进行静态分析，不利于进行静态优化，也不利于做LSP辅助，它的主要优势是可以为DSL开发者提供强大的表达能力（类似Lisp思想），但如果想要针对AI领域有所作为则会在性能、安全和易用性上带来较大缺陷。所以该问题从根本上是用户群体取向问题，即究竟是面向无数小领域的DSL开发者还是面向未来前景如火如荼地AI大领域从业者的问题。

最终决定移除该特性。

移除该特性后，可以引入一些曾经因语法分析困难而舍弃的特性，比如一些字面量的表达式。

另外，需引入import from语法。

2、对于赋值操作的支持问题

单纯的赋值操作会在底层的计算图中引入环路，使其不再成为一个有向无环图，这与语言的核心定位发生了冲突。但赋值操作又是众多语言的公有特性，即便是很多纯函数式语言，也在某种程度上放开了对数据修改的支持。事实上，即便不支持赋值，也无法避免底层函子在框架级别对数据进行修改，这是便利性和高效性的必然需要。另外，想要支持AI模型训练，就必然离不开对状态和参数的修改，以及对分支和循环的支持。所以，必须找出一种既支持数据动态修改也不至于底层变成有环图的方案。

深入考察这个问题的本质，其实在于一个数据节点的依赖节点对齐数据在不同时段的依赖问题。有些后继节点可能需要该数据的初始版本，而有些后继节点可能需要该数据的最新版本。在有向无环图的调度中，不同节点之间调度的时间先后顺序本来仅取决于节点之间的数据依赖关系，而没有在代码中书写的先后之分。但不同节点在代码中声明的顺序其实隐含了其对于某个公共数据的依赖顺序。假设有以下代码：

```
let a = 1;
print(a); // a->print
a = a + 1; // [a, 1]->plus->a
print(a); // a->print
```

可见，当第三行代码对a进行修改之后，该行之后的所有代码在语义上应该依赖的是最新版本的a。因此，可以对现有的语言做如下修改：

- 显式追踪所有可能修改变量的操作，并要求用户显式标记其所在的行。
  - 引入var关键字，用于修饰变量和函数参数，便于编译器追踪分析对变量的修改操作。
  - 引入wait关键字，后跟可能产生副作用的表达式，用于划分被影响的变量的版本。
- 以wait划分的代码为界，将其下的代码对源数据的依赖转移到新的数据节点，并将该节点的前置条件设为有副作用的操作节点。
  - 引入新的节点类型，WAITNODE，其输入，一个是副作用节点，另一个是原数据节点。

```
var a = 1;
print(a); // a->print
wait a = a + 1; // [a, 1]->plus->a1
print(a); // a1->print

func test(a: Int) {}
func test(var a: Int) {}
```



## 2024年9月18日

1、关于与SPL（Stream Processing Language）的关系的思考

OpenCML与SPL的定位其实有很大不同

- CML不支持流，SPL为流打造
- CML是中心化调度的，SPL是去中心化、分布式的
- CML同一个线程可以执行多个节点，SPL每个节点都代表一个隔离机器

2、关于函子输入输出行为规范的思考

目前函子是单输入、单输出的，后面要经过多遍图优化才能展开，而包含递归的函子是不能展开的（即需要是ATOMIC的）

但这里有一个关键问题，有时候我们只想给一个参数，或者直接拿到一个输出，并不想手动再封装一次列表或者解包一次列表，这会带来一些不清晰的问题。

对于返回值这个问题比较好解决，因为返回值可以明确声明返回类型是一个列表，或者是元组，因为返回值只有一个。

可以规定函数参数也只有一个，即Param类型，而PARAM类型可以被LIST类型、TUPLE类型甚至是DICT类型赋值，但我还希望其可以被单变量赋值。这里有一个问题在于，单变量本身也可能是LIST或者TUPLE，这要求PARAM可以根据单变量的具体类型进行自动展开。还好的是，目前对CML的定位是静态强类型语言，这样做也许不会有太多麻烦，但总会引入一些复杂展开规则，这可能成为后面的雷点。

而且还要考虑的是，即使单变量本身是一个可展开对象，但如果开发者不希望触发PARAM的自动展开，就必须有一些手段阻止，其实一个可行的办法是在外层套一个匿名列表，以避免自动展开。

```
[[], ]
```

3、关于内置特殊数据结构字面量语法的思考

对于内置的结构化数据结构最好应该有字面量初始化语法，原因如下：

- 数据结构需要初始化，由于不支持泛型模板参数所以不建议使用构造函子做初始化
- 崇尚不可变数据，一般不会出现逻辑构造，所以字面量结构化构造是最为简洁的方式

对于同构结构化数据，在初始化时需要指定元素类型，所以这并不是换不同的括号的问题，而是需要类型模板参数的问题

后面需要针对类型系统作进一步优化



## 2024年9月26日

有关图共享及其数据管理的一些思考

要实现的目标是什么呢？因为函子是需要共享的，而函子本质上是一个子图，其实也就是子图的共享问题。我们不能直接共享同一个子图的节点和数据，因为我们需要实现同一个图结构被放在不同的上下文中产生不同的运算结果，如果中间变量被直接复用，那只能得到相同的运算结果，这样做还可能造成数据污染，导致计算结果的不确定性。那我们完全拷贝整个图，包括结构和数据是否可行？这样做确实可以避免数据的不确定性，但随之而来的问题是，如果我们每次调用一个函数，都要将所有的图节点及其互相之间的拓扑关系都复制一遍，这将带来不可忽视的巨大开销，而这些开销并不是必要的。所以我们的目标就很清晰了，即设计一套方案，实现图结构和一些必要数据的共享（例如静态常量），而对于同一个图节点，使其在不同的上下文中拥有独立的数据。

数据可以分为几种类型呢？根据共享性和可变性可以粗略地划分为下面四类：

- STATIC_CONSTANT：静态常量，在编译期即可确定的常量，也包括变量的初始值
- STATIC_VARIABLE：静态变量，在编译期可以确定值，但会在运行时动态改变，且会被多个图实体共享的数据
- RUNTIME_CONSTANT：运行时常量，运行时由函子生成的不可变数据
- RUNTIME_VARIABLE：运行时变量，运行时由函子生成的可变数据

编译期类型转变，只支持常量到变量的转换，变量到常量的转换没有实际意义，只需要假设所有节点初始化时都是常量，而后根据后续AST分析过程来决定其是否应该是一个变量。以及必须是编译期的类型转换，目前暂不考虑运行时的类型转换。

所以，只可能是静态常量转换为静态变量或者运行时变量。

每个图节点保留自己的数据索引，每当外界通过图节点访问其数据时，该节点通过保存的索引去向自己所在的图实体获取真正的数据指针并返回。这有一点类似虚拟内存的思想，使用数据的图节点所持有的并不是指向数据的指针，而只是向图实体（负责保存数据）申请数据的索引。这样，我们在复制图实体时就无需担心数据的混用。

在图实体复制时，副本完全引用原图所有图节点，以及原图的静态常量和静态变量的存储容器，只对运行时常量和变量重新初始化，以达到最小的复制开销。