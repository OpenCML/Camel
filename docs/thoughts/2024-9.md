可能向函数式编程语言全面转型



原来的定位是基于DAG的通用DSL框架



现在定位是基于函数式思想的ML前端脚本语言

要可优化

要ML导向



经典的函数式编程语言

OCaml/Haskell/Scheme(Lisp)/Scala



静态类型检查太诱人了

性能优化、安全检查、函数重载



实体链本质上是为了方便DSL开发者创建更好的表达

但对于AI领域来说，弊大于利

其动态性太强了，无法做类型推断，无法做展开优化，甚至其语法结构对分号有强依赖，不利于parser优化，其空格表达式的结构也妨碍了许多字面量语法

利用其实现if/for/from，一方面不如引入新的关键字以实现更好的优化，另一方面if/for与函数式语言的基本习惯相违背，

其实也没有必要为一种效果提供多种写法

总之是一个比较无聊的设计





思考大致有了一些结论

1、对于实体链语法的问题

这本质上是一个是否采用一个高动态的概念的问题，实体链的执行过程难以进行静态分析，不利于进行静态优化，也不利于做LSP辅助，它的主要优势是可以为DSL开发者提供强大的表达能力（类似Lisp思想），但如果想要针对AI领域有所作为则会在性能、安全和易用性上带来较大缺陷。所以该问题从根本上是用户群体取向问题，即究竟是面向无数小领域的DSL开发者还是面向未来前景如火如荼地AI大领域从业者的问题。

最终决定移除该特性。

移除该特性后，可以引入一些曾经因语法分析困难而舍弃的特性，比如一些字面量的表达式。

另外，需引入import from语法。

2、对于赋值操作的支持问题

单纯的赋值操作会在底层的计算图中引入环路，使其不再成为一个有向无环图，这与语言的核心定位发生了冲突。但赋值操作又是众多语言的公有特性，即便是很多纯函数式语言，也在某种程度上放开了对数据修改的支持。事实上，即便不支持赋值，也无法避免底层函子在框架级别对数据进行修改，这是便利性和高效性的必然需要。另外，想要支持AI模型训练，就必然离不开对状态和参数的修改，以及对分支和循环的支持。所以，必须找出一种既支持数据动态修改也不至于底层变成有环图的方案。

深入考察这个问题的本质，其实在于一个数据节点的依赖节点对齐数据在不同时段的依赖问题。有些后继节点可能需要该数据的初始版本，而有些后继节点可能需要该数据的最新版本。在有向无环图的调度中，不同节点之间调度的时间先后顺序本来仅取决于节点之间的数据依赖关系，而没有在代码中书写的先后之分。但不同节点在代码中声明的顺序其实隐含了其对于某个公共数据的依赖顺序。假设有以下代码：

```
var a = 1;
print(a);
a = 2;
print(a);
```

可见，当第三行代码对a进行修改之后，该行之后的所有代码在语义上应该依赖的是最新版本的a。因此，可以对现有的语言做如下修改：

- 显式追踪所有可能修改变量的操作，并要求用户显式标记其所在的行。
  - 引入var关键字，用于修饰变量和函数参数，便于编译器追踪分析对变量的修改操作。
  - 引入wait关键字，后跟可能产生副作用的表达式，用于划分被影响的变量的版本。
- 以wait划分的代码为界，将其下的代码对源数据的依赖转移到新的数据节点，并将该节点的前置条件设为有副作用的操作节点。
  - 引入新的节点类型，WAITNODE，其输入，一个是副作用节点，另一个是原数据节点。