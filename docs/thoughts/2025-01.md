# 关于扩展性设计

Python以其高可扩展性优势在脚本语言中脱颖而出，cml的算子扩展性至少要与Python对齐，而调度扩展性则要全面优于Python

算子扩展性

调度扩展性

调度分为图优化器和图调度器，其实本质上没有区别，都是以图作为输入，以图作为输出（调度器可以输出空图）

调度器按照作用范围分类可以有两种，一种是局部调度器（macro函数），另外一种是全局调度器（macro main函数）

同一个模块内可以同时存在main和macro main函数，它们互不冲突。

因为main函数不会在代码内被引用调用，所以不用担心代码内无法区分标识符所指。

而解释器层的入口，解释器可以根据是否有前置图输入来决定使用哪个入口。

图优化器的输出应当有接收方，对于全局的图优化器应当指定多层，确保最后一图调度器结尾

所以全局调度器应该可以指定多个。多层调度器的定义最好也是由CML代码实现

main函数可以接收函子作为参数

可以使用类似下面的方法应用多个调度器：

注意，这里由于管道运算符`|`已经被bash征用，所以选用了`->`

```
camel main.cml -> opt.cml -> sched.cml
```

sched.cml的输出结果会被送往camel默认的调度器（内置调度器），当然如果sched已经完成大部分计算，只需要输出空图即可。

内置调度器可以提供一些参数设置，用于决定具体的调度算法等超参数。

可以将多层cml设置为默认调度器，camel内置也会有多遍优化，它们有内置的名字，可以使用类似下面的语法来指定使用内置调度器：

```
camel main.cml -> std::opt -> std::onnx
```

底层调度器的选用和参数可以用cmlconfig.json指定，可以使用`camel run`来执行其中的脚本定义

该配置文件可以指定入口，如果不在命令行中指定入口则使用配置文件指定的入口。



下面讲讲`inner`，`outer`，`macro`三个关键字

INNER：代表该函子由内置C++代码实现（静态链接，在运行时已注册到camel解释器中），一般用于标准库的动态启用，inner函子修饰的函数可以不给出实际实现，事实上，即便给出了实际实现也会被忽略。方法体内一般可以写一些注释。

OUTER：代表该函子由外部的代码实现（FFI），采用动态链接库方法，一般用于第三方库的底层实现，outer函子应当返回一个字符串常量，用于表示FFI的类型和链接库的具体位置，例如：

```
outer func test(arg: Any): Void { 'dll://xxx.so::xxx' }
// 又或者
let fn = outer (arg: Any): Void => 'python://xxx.py::func' // exec://path/to/lib::ident
```

注意，FFI一般指C/C++的接口，对于python的接口，暂定使用python调度器来完成。camel不会默认把python解释器内置到可执行程序内。

MACRO：简单粗暴，就是编译期执行的函数。camel解释器保证在编译期结束后，所有的macro函数都得到执行，macro可以对图进行优化和调度执行，输入参数应当是子图（或者是数据节点），其返回结果也应当是子图（或者单节点数据）。所有的调度器本质上就是一个macro函数。



现在指出上述设计的问题。

按上述设计，调度器是严格分层的，这会导致一个问题，即某层调度器可能无法处理其中的某些函子，导致无法完全完成其任务。

或者说，某些函子的计算可能依赖于后续调度器的执行。

所以中间层只能是纯粹地图优化器，而调度器应当按顺序放在最后，且只能选择一个。

比如，tf既有图优化器tf::opt，又有图调度器tf::rt，而同时代码中用到了python接口，甚至同时使用了js接口，

那么在opt时，tf并不知道涉及到python和js的函子是否要做一些处理，导致不能完全发挥优化的优势，而如果再使用python的调度器，则其可能因为无法调度js代码而不能执行。

所以可能要引入执行器的概念，因为执行器应当是懒加载的，即只有当需要它时才会执行某个传入的outer函数。调度器应当只决定执行顺序。

执行器是被动的，所以其不是一个macro函数，而是一个plugin插件，可以在camel命令行中设置，也可以在配置文件中设置。

```
camel xxx --executors python,dll,nodejs
```

另外，执行器互相之间可以继承引用，这样可以实现更加多样化的执行器。

例如，matplotlib执行器依赖于python基础执行器。执行器加载时可以声明自己的依赖，以便camel首先加载好别的执行器并将基础执行器实例传递给上层执行器。

由于优化器和调度器本质上就是一个macro函数，其自然也可以用其他的macro函数，故本身就可以继承引用。

camel包管理需要管理三种类型依赖，分别是源码依赖、FFI库依赖和执行器依赖。其中，库依赖又分为一般算子库依赖和调度库依赖。camel本身还要做好缓存的管理（缓存仅缓存编译期结果，不缓存执行期结果，也就是说每次执行只会省下解析编译和静态检查的时间，而不会省下图优化的时间。因为图优化可能会优化掉某些暂时用不到但其他模块可能用到的东西，甚至有可能直接得到执行结果产生副作用，所以无法保证每次执行结果一致。如果想要build，可以自己接其他的图优化遍并生成优化结果，然后自行加载对应的优化结果执行。）

所有这些依赖都有全局非全局之分，到时候参考nodemodules实现。

每个包都有配置文件，声明其contributions，比如是否有图优化器，其入口在哪里，名称和别称有什么（思考，如何解决命名冲突？每个包必须有全称，而且要全局唯一），是否有执行器等。调度器和优化器虽然本质一样，但要做出标记（type），因为调度器默认输出为空图并产生可观的副作用，camel会自动完成一些必要的检查（比如，在调度器之后再跟优化器或者调度器是没有意义的）。

但是有个问题，调度器一定是进行完全调度吗？就i不能部分调度部分优化吗？甚至可能是部分计算并得到缓存，下次自动加载缓存？其实不要做太多限制为好。

但是调度器可能需要一些外界参数，比如指定线程数量和资源限制等等。局部调度器可以通过显式的macro传参，全局调度器可能就需要json配置了，所以，macro main函数所接受参数，普通参数只有一个且是子图，超参数可以有多个但必须有默认值。

包应当声明自己所需要的执行器，保证自己可以被正确执行，在下载安装包依赖时，所需执行器也会一并被安装。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          







## 一些语法细节的优化

内置原子类型现在统一改为小写，以便与外源原子类型区分。

外源类型设计者现在可以设计名为`Int`的类型。

对于某些需要大量修改值的场景，原来的写法应当是：

```
{
	wait a = b
	wait b = c
	wait c = d
}
```

事实上，不难发现上述写法等效为：

```
{
	wait sync {
		a = b
		b = c
		c = d
	}
}
```

语法已进行微调以适配该写法。





## 关于Macro与Generics

Camel其实可以设计成一门宏语言

也就是说camel解释器只负责解析代码并执行其中的宏

其实现代的语言实践已经发明了许多的宏

比如以C++为代表的字符串替换宏

以rust为代表的tokens宏

以OCaml为代表的AST宏

还有camel的一个核心特性，graph宏



camel由于在设计上更偏向于括号语言，所以对泛型的支持是受限的

camel目前允许对于类型使用<>以表示泛型参数，这要求类型和值在语言中必须是独立的槽

换句话说，该写类型的地方绝不能写值，以免给解析带来混乱

但是对于函数来说，函数本身作为可以被传递的值尤其需要泛型

所以目前camel只支持可以自动推导的的泛型函数

当然，函数复用不仅仅只能依靠泛型参数实现

事实上，类似接口的设计也有助于函数复用



参考rust的设计：

```rust
fn print_debug_and_clone<T: std::fmt::Debug + Clone>(item: T) {
    println!("{:?}", item.clone());
}
```

这里尖括号中的冒号就代表类型的约束，这很符合直觉

camel由于尖括号已被超参数占用，无法用于表示类型约束关系

但是camel采用了鸭子类型设计理念，即当一个对象具备所需要的成员，他自然可以被视作该类型的数据

这可以被理解为一种隐式的类型转换

从本质上来说，OCaml 的宏（特别是通过 ppx 实现的 AST 宏）就是**输入为 AST 且输出为 AST 的函数**。不过，它们的使用方式和普通函数稍有不同，因为它们的运行时机是在**编译阶段**，而不是程序运行时。

ocamel也需要在某个代码中定义AST转换器并注册为宏，而后在命令行中通过-ppx附加该宏

这和camel的设计异曲同工，不过camel做的更加彻底，即直接将整个代码的执行过程解释为宏的逐遍执行

由于camel的macro函数既可以是outer也可以是平凡定义（即使用camel本身的语法特性实现）的

所以camel中更需要有操作图的能力，更需要是以函数（子图）为一等公民

这也就是`..`运算符存在的极大意义



这种类型约束其实被鸭子类型和隐式类型转换解决了

这其实已经解决了大半对于函数复用的需求

而对于一些全对象通用的函数也可以用any等模糊类型解决（dict，list，tuple）

（其实这里的命名可以考虑改成object/record, array, tuple)

list会让人联想到异质列表，但其实在camel中需要显式声明为any[]

object没有类型参数，它代表所有record对象

array<T>和T[]等价，T可以忽略

tuple<T1, T2...>和 (T1, T2...)等价，也可以忽略



对于一些特定的情况，我们可能需要根据函数输入类型来决定返回类型，这就需要临时定义类型或可推导类型

有时候我们需要判断类型是否满足某些条件

其实可以从底层实现一些类型，比如Iterable，Callable

然后允许它们相加得到新的类型，比如 Iterable & Callable

因为camel的鸭子类型判断机制并不是机械地检查两种类型构型是否一致，而是调用它们之间的类型转换判断函数，所以第三方库开发者可以轻易地让别的类型可以转换到自己

A & B（和类型 MergeType）代表C必须同时满足A类型和B类型，强调满足两种类型要求的值的集合取交集，也就是类型取并集，可以读作A and B，要求AB是可求和的。

A ^ B（交类型 JointType）代表C必须满足AB之间的交集部分，强调两种类型本身取交集，也就是值取并集，这要求AB是可交的（存在A到B以及B到A的类型求交函数，JointType，Joint意为连接点，交汇点，而不是取全部的含义，用在类型上可以表示类型的共有部分。特别的，多次运算应当得到void，也就是说，空类型代表空值，或者应当禁止无交集的类型出现，即对于可交但返回void的情形应当予以禁止。

A | B（并类型 UnionType） 代表C可以满足A或B类型，类型取并集，值也取并集，多次运算可能得到any



Rust 可以通过特质（Trait）约束和宏（Macro）来部分实现类型交集

TS通过类型工具来手动计算交类型：

```typescript
type A = { name: string; age: number };
type B = { age: number; gender: string };
type C = Pick<A, Extract<keyof A, keyof B>>; // { age: number }
```



由于camel采用了graph macro，所以更需要一种为图节点（包含数据、操作和子图）添加meta信息的机制，即注解机制

这才应当是camel设计注解的核心出发点



其实现代许多语言越来越强调编译期执行代码的能力，比如Zig或Terra的Staged Functions

Camel在这里做得更彻底，在某种程度上已经混淆了编译期和执行期，只是简单的抽象成图优化和图调度问题，而图调度也可以被视为图优化的一种特殊情况，只是会产生副作用。

编译时计算的目标是优化运行时计算，在Camel中你可以自定决定哪些代码放到运行时。Camel缓存本质上是提供一种dump和load图结构的能力。

这里可以写一些理论部分以及与其它语言的设计对比，抽空写一下。

换句话说，讨论语言设计的Generic的能力。

OpenCML2可以再发一篇小论文，实现依然推迟，先投出去拿一些反馈。

可以提到的关键词：

> **多阶段编程**（Multi-Stage Programming，简称 MSP）是一种编程范式，它将程序的执行划分为多个阶段，每个阶段可以动态地生成或优化后续阶段的代码。这种技术的核心思想是：**利用当前阶段的信息动态生成下一阶段的代码，避免生成通用代码的性能损耗**，从而实现更高效、更灵活的程序运行。
>
> 简单来说，多阶段编程允许你在程序运行的不同阶段动态生成、优化和执行代码，而不是仅仅依赖静态编译时生成的固定代码。





## 关于计算图

其实计算图有多种表示方法，关键在于节点和边分别代表什么，以及是否有其他的信息在里面

目前主流大致有三种：

1、节点代表数据，边代表操作

工程实现会更自然，数据流图也是如此设计。

pytorch和tf2.0倾向于此

2、节点代表操作，边代表数据

这种设计通常更加理论导向，更接近于对计算流程的抽象化建模，反向传播可以看作沿着边传播梯，每个节点执行计算。

早期tensorflow采取此策略

3、节点同时代表操作和数据，边代表数据依赖关系

其实这个实现和前两种选择没有本质区别，或者说，没有工程实现上的区别

因为即便是操作节点，其本身也被视为存储了操作得到结果的数据节点，也就是说，在这个实现中，其实节点就是代表数据的，只不过我们没有用额外的空间来存储边对象，并把操作存储在了与边相连的对应节点之上。事实上，操作不可能完全地存储在边上，因为对于多输入操作，把操作分散存储在每一条输入边上是愚蠢的。既然这些操作都指向同一个输出结果，那么把具体操作存储在输出结果所对应的节点上就显得非常合理。

同样的，工程上一个节点就是既可以代表操作也可以代表其产生的数据，所以也没必要把数据放在边上。或者说，我们通过边来获知依赖的数据节点，可以将其视为数据在边上。前两种方案本质上是简化的数学模型，而工程上只需要结点这一种存储数据的数据结构。



camel一共有三种节点：

数据节点DataNode，算子节点OperatorNode，子图节点SubgraphNode

同样的，有三种边

超参依赖WithEdge，参数依赖LinkEdge，控制依赖CtrlEdge



参数依赖应当是有顺序的，即在实现上需要使用向量结构。换句话说，每个节点所存储的输入边应当由三个节点指针向量表示。为实现简单，目前统一使用临时的中间数据对象节点表示，这有无必要呢？

或者说，这有何好处，有何坏处，是否是必要的？这其实并不直观，也需要至少一个pass来消除。

因为在构造过程中，目前的构造算法可以拿到参数组对象，盲目拆开可能有一些信息无法拿到。

同时还要考虑和类型系统算法结合，在完成类型系统检查的同时构造好计算图，这是下一阶段的核心目标。

为了实现此目标，可能需要重新考虑GCT的设计。

另外还要考虑好如何在执行的过程中完成宏规约。

寒假有事情做了。AST设计，GCT设计，GIR设计，类型系统设计实现。

另外要实现图渲染模块，并实装到插件中。



## 关于流式处理

其实可以完全由调度函子决定



## 关于高阶函数

函数作为值，如何在图中表达？

inline functor如何表达？

函数作为值是等待展开吗？inline functor是这样的

函数作为子图输入，会在子图内被调用，内联函子可以直接展开，复杂函子不会



## 关于一些案例

```
var w: Tensor = Tensor::new()
var b: Tensor = Tensor::new()
let x: Tensor = Tensor::new()
let y: Tensor = Tensor::new()

// forward 函子定义
with <w: Tensor, b: Tensor>
func forward(x: Tensor): Tensor {
	return w * x + b
}
// 用法
let y_hat = forward<w, b>(x)
// 或者写成
let y_hat = x->forward<w, b>

// 使用宏函子apply_gradients为前向传播图添加梯度计算部分
// 宏函子是输入和输出均是函子（也就是子图）的函子
// 这里要先把forward和loss函子连接之后再添加反向传播图
let train = apply_gradients(forward<w, b>..loss)
// 上述表达式的返回值等同于下述函子定义
// 注意，apply_gradients虽然接收的是一个无副作用函子
// 但其返回的函子是有副作用的，因为要修改权重
with <var w: Tensor, var b: Tensor, lr: float>
sync func train(x: Tensor, y: Tensor): Tensor {
	let y_hat = forward<w, b>(x)
	let pl_py = y_hat - y
	wait b = b - lr * pl_py
	wait w = w - lr * pl_py * x
	return loss(y_hat, y)
}
// usage
// train有副作用（会修改w和b的值）所以要使用wait关键字
let l = wait train<w, b, 0.01>(x, y)
```

遇到一个问题，如果被连接的两个函子各自有不同的超参数，那么连接后的内联函子应当有怎样的超参数呢？其实建议使用.运算符补全超参数。
