# 关于扩展性设计

Python以其高可扩展性优势在脚本语言中脱颖而出，cml的算子扩展性至少要与Python对齐，而调度扩展性则要全面优于Python

算子扩展性

调度扩展性

调度分为图优化器和图调度器，其实本质上没有区别，都是以图作为输入，以图作为输出（调度器可以输出空图）

调度器按照作用范围分类可以有两种，一种是局部调度器（macro函数），另外一种是全局调度器（macro main函数）

同一个模块内可以同时存在main和macro main函数，它们互不冲突。

因为main函数不会在代码内被引用调用，所以不用担心代码内无法区分标识符所指。

而解释器层的入口，解释器可以根据是否有前置图输入来决定使用哪个入口。

图优化器的输出应当有接收方，对于全局的图优化器应当指定多层，确保最后一图调度器结尾

所以全局调度器应该可以指定多个。多层调度器的定义最好也是由CML代码实现

main函数可以接收函子作为参数

可以使用类似下面的方法应用多个调度器：

注意，这里由于管道运算符`|`已经被bash征用，所以选用了`->`

```
camel main.cml -> opt.cml -> sched.cml
```

sched.cml的输出结果会被送往camel默认的调度器（内置调度器），当然如果sched已经完成大部分计算，只需要输出空图即可。

内置调度器可以提供一些参数设置，用于决定具体的调度算法等超参数。

可以将多层cml设置为默认调度器，camel内置也会有多遍优化，它们有内置的名字，可以使用类似下面的语法来指定使用内置调度器：

```
camel main.cml -> std::opt -> std::onnx
```

底层调度器的选用和参数可以用cmlconfig.json指定，可以使用`camel run`来执行其中的脚本定义

该配置文件可以指定入口，如果不在命令行中指定入口则使用配置文件指定的入口。



下面讲讲`inner`，`outer`，`macro`三个关键字

INNER：代表该函子由内置C++代码实现（静态链接，在运行时已注册到camel解释器中），一般用于标准库的动态启用，inner函子修饰的函数可以不给出实际实现，事实上，即便给出了实际实现也会被忽略。方法体内一般可以写一些注释。

OUTER：代表该函子由外部的代码实现（FFI），采用动态链接库方法，一般用于第三方库的底层实现，outer函子应当返回一个字符串常量，用于表示FFI的类型和链接库的具体位置，例如：

```
outer func test(arg: Any): Void { 'dll://xxx.so::xxx' }
// 又或者
let fn = outer (arg: Any): Void => 'python://xxx.py::func' // exec://path/to/lib::ident
```

注意，FFI一般指C/C++的接口，对于python的接口，暂定使用python调度器来完成。camel不会默认把python解释器内置到可执行程序内。

MACRO：简单粗暴，就是编译期执行的函数。camel解释器保证在编译期结束后，所有的macro函数都得到执行，macro可以对图进行优化和调度执行，输入参数应当是子图（或者是数据节点），其返回结果也应当是子图（或者单节点数据）。所有的调度器本质上就是一个macro函数。



现在指出上述设计的问题。

按上述设计，调度器是严格分层的，这会导致一个问题，即某层调度器可能无法处理其中的某些函子，导致无法完全完成其任务。

或者说，某些函子的计算可能依赖于后续调度器的执行。

所以中间层只能是纯粹地图优化器，而调度器应当按顺序放在最后，且只能选择一个。

比如，tf既有图优化器tf::opt，又有图调度器tf::rt，而同时代码中用到了python接口，甚至同时使用了js接口，

那么在opt时，tf并不知道涉及到python和js的函子是否要做一些处理，导致不能完全发挥优化的优势，而如果再使用python的调度器，则其可能因为无法调度js代码而不能执行。

所以可能要引入执行器的概念，因为执行器应当是懒加载的，即只有当需要它时才会执行某个传入的outer函数。调度器应当只决定执行顺序。

执行器是被动的，所以其不是一个macro函数，而是一个plugin插件，可以在camel命令行中设置，也可以在配置文件中设置。

```
camel xxx --executors python,dll,nodejs
```

另外，执行器互相之间可以继承引用，这样可以实现更加多样化的执行器。

例如，matplotlib执行器依赖于python基础执行器。执行器加载时可以声明自己的依赖，以便camel首先加载好别的执行器并将基础执行器实例传递给上层执行器。

由于优化器和调度器本质上就是一个macro函数，其自然也可以用其他的macro函数，故本身就可以继承引用。

camel包管理需要管理三种类型依赖，分别是源码依赖、FFI库依赖和执行器依赖。其中，库依赖又分为一般算子库依赖和调度库依赖。camel本身还要做好缓存的管理（缓存仅缓存编译期结果，不缓存执行期结果，也就是说每次执行只会省下解析编译和静态检查的时间，而不会省下图优化的时间。因为图优化可能会优化掉某些暂时用不到但其他模块可能用到的东西，甚至有可能直接得到执行结果产生副作用，所以无法保证每次执行结果一致。如果想要build，可以自己接其他的图优化遍并生成优化结果，然后自行加载对应的优化结果执行。）

所有这些依赖都有全局非全局之分，到时候参考nodemodules实现。

每个包都有配置文件，声明其contributions，比如是否有图优化器，其入口在哪里，名称和别称有什么（思考，如何解决命名冲突？每个包必须有全称，而且要全局唯一），是否有执行器等。调度器和优化器虽然本质一样，但要做出标记（type），因为调度器默认输出为空图并产生可观的副作用，camel会自动完成一些必要的检查（比如，在调度器之后再跟优化器或者调度器是没有意义的）。

但是有个问题，调度器一定是进行完全调度吗？就i不能部分调度部分优化吗？甚至可能是部分计算并得到缓存，下次自动加载缓存？其实不要做太多限制为好。

但是调度器可能需要一些外界参数，比如指定线程数量和资源限制等等。局部调度器可以通过显式的macro传参，全局调度器可能就需要json配置了，所以，macro main函数所接受参数，普通参数只有一个且是子图，超参数可以有多个但必须有默认值。

包应当声明自己所需要的执行器，保证自己可以被正确执行，在下载安装包依赖时，所需执行器也会一并被安装。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          







## 一些语法细节的优化

内置原子类型现在统一改为小写，以便与外源原子类型区分。

外源类型设计者现在可以设计名为`Int`的类型。

对于某些需要大量修改值的场景，原来的写法应当是：

```
{
	wait a = b
	wait b = c
	wait c = d
}
```

事实上，不难发现上述写法等效为：

```
{
	wait sync {
		a = b
		b = c
		c = d
	}
}
```

语法已进行微调以适配该写法。
